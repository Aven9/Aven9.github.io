<!DOCTYPE html><html lang="en-us"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>iOS Memory Management | Aven's Blog</title><meta name="description"><meta name="generator" content="Aven's Blog"><meta name="author" content="Wenjie Zhang"><meta name="keywords" content="Developer, Computer Science"><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1,user-scalable=0"><link rel="stylesheet" type="text/css" href="/styles/screen.css"><link rel="apple-touch-icon" sizes="57x57" href="/images/apple-touch-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/images/apple-touch-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/images/apple-touch-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/images/apple-touch-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/images/apple-touch-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/images/apple-touch-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/images/apple-touch-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/images/apple-touch-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-180x180.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/images/favicon-96x96.png"><link rel="icon" type="image/png" sizes="128x128" href="/images/favicon-128.png"><link rel="icon" type="image/png" sizes="196x196" href="/images/favicon-196x196.png"><meta name="msapplication-TileColor" content="#FFFFFF"><meta name="msapplication-TileImage" content="mstile-144x144.png"><meta name="msapplication-square70x70logo" content="mstile-70x70.png"><meta name="msapplication-square150x150logo" content="mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="mstile-310x150.png"><meta name="msapplication-square310x310logo" content="mstile-310x310.png"></head><body itemscope itemtype="https://schema.org/WebPage"><header itemscope itemtype="https://schema.org/WPHeader"><div class="logo"></div><h1><a href="/" alt="Aven's Blog" title="Aven's Blog" itemprop="headline">Aven's Blog</a></h1><p itemprop="description"></p><nav itemscope itemtype="https://schema.org/SiteNavigationElement"><ul><li itemprop="name"><a href="/ " alt="home" title="home" itemprop="url">home</a></li><li itemprop="name"><a href="/articles" alt="articles" title="articles" itemprop="url">articles</a></li><li itemprop="name"><a href="/author" alt="author" title="author" itemprop="url">author</a></li></ul></nav><div class="space"></div></header><main itemscope itemtype="https://schema.org/Blog"><article class="full"><h1 itemprop="headline" class="post-heading">iOS Memory Management</h1><span class="page-tag-anchor"><a href="/tags/OC" itemprop="url">#OC
&nbsp;&nbsp;</a></span><span class="post-meta"></span><br><br><h1 id="OC中的内存管理"><a href="#OC中的内存管理" class="headerlink" title="OC中的内存管理"></a>OC中的内存管理</h1><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><h3 id="理解和使用引用计数"><a href="#理解和使用引用计数" class="headerlink" title="理解和使用引用计数"></a>理解和使用引用计数</h3><p>说到OC中的内存管理，便要从引用计数这个概念作为切入点来理解。简单来说，引用计数即是一种在需要持有对象的时候进行计数增，释放的时候进行计数减的机制，理论上来说，计数为0的时候即是对象声明周期结束、应当被销毁的时候。因为无人引用的时候对象便不再被需要。但更客观的思考方式应该注意到应该由谁持有和应该由谁释放的问题，具体来说有以下几个原则：</p>
<ul>
<li>自己生成的对象，自己持有</li>
<li>非自己生成的对象，自己也能持有</li>
<li>不再需要自己持有对象时应当释放</li>
<li>非自己持有的对象无法释放</li>
</ul>
<p>分别对应的OC方法如下表所示：</p>
<table>
<thead>
<tr>
<th>对象操作</th>
<th>OC方法</th>
</tr>
</thead>
<tbody><tr>
<td>生成并持有对象</td>
<td>alloc/new/copy/mutableCopy</td>
</tr>
<tr>
<td>持有对象</td>
<td>retain</td>
</tr>
<tr>
<td>释放对象</td>
<td>release</td>
</tr>
<tr>
<td>销毁对象</td>
<td>dealloc</td>
</tr>
</tbody></table>
<p>举个例子：</p>
<pre><code class="objective-c">/**自己生成并持有对象**/
id obj = [[NSObject alloc] init];
/**自己持有对象**/
/**释放对象**/
[obj release];
/**对象已被释放，不可再被访问**/</code></pre>
<p>另一种方式：</p>
<pre><code class="objective-c">/**生成对象但并不持有, 此时引用计数为0**/
id obj = [NSMutableArray array];
/**持有对象**/
[obj retain];
/**自己持有对象**/
/**释放对象**/
[obj release];
/**对象已被释放，不可再被访问**/</code></pre>
<p>如果企图释放计数已经为0的对象或者是自己没有持有的对象，将会造成程序崩溃。</p>
<h3 id="Autorelease"><a href="#Autorelease" class="headerlink" title="Autorelease"></a>Autorelease</h3><p>除了<code>retain</code>和<code>release</code> 之外，还有一种用于操作计数器的方法：<code>autorelease</code>. <code>autorelease</code>将引用计数递减这一活动延后执行。</p>
<p><code>autorelease</code>的使用方法如下：</p>
<ul>
<li>生成并持有<code>NSAutoreleasePool</code>对象</li>
<li>调用已分配对象的<code>autorelease</code>实例方法</li>
<li>废弃<code>NSAutoreleasePool</code>对象</li>
</ul>
<pre><code class="objective-c">/**生成并持有NSAutoreleasePool对象**/
NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
id obj = [[NSObject alloc] init];
/**调用已分配对象的autorelease实例方法**/
[obj autorelease];
/**废弃NSAutoreleasePool对象**/
[pool drain];</code></pre>
<p>但是在<code>Cocoa</code>框架中，在充当程序主循环的<code>NSRunloop</code>或其他可运行程序的地方都会对<code>NSAutoreleasePool</code>对象进行生成、持有、废弃处理，因此不必非要采用<code>NSAutoreleasePool</code>对象手动管理资源的生成、持有、释放。</p>
<p><img src="./iOS-Memory-Management/NSAutoreleasePoolCircle.jpeg" alt="NSAutoreleasePoolCircle"></p>
<p>但是，在这种模式下，当大量产生<code>autorelease</code>对象时，只要<code>NSAutoreleasePool</code>对象没有废弃，那么对象也不能被释放，因此会带来内存不足的问题，此时需要在适当的位置手动生成、持有、废弃<code>NSAutoreleasePool</code>对象。</p>
<p>例如，在读入图像文件，生成UIImage对象时：</p>
<pre><code class="objective-c">for(int i = 0; i &lt; imageCount; ++i) {
  NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];

  /**读入图像文件, 产生需要autorelease的对象**/

  [pool drain];    //此时，对象及时被释放；
}</code></pre>
<h2 id="自动引用计数"><a href="#自动引用计数" class="headerlink" title="自动引用计数"></a>自动引用计数</h2><h3 id="ARC特性简介"><a href="#ARC特性简介" class="headerlink" title="ARC特性简介"></a>ARC特性简介</h3><p>ARC仍然采用的是引用计数式内存管理的机制，只不过<code>retain</code>和<code>release</code>由ARC自动添加，因此，在ARC下这些内存管理方法是不可被开发者调用的：</p>
<ul>
<li><code>retain</code></li>
<li><code>release</code></li>
<li><code>autorelease</code></li>
<li><code>dealloc</code></li>
</ul>
<p>此外，ARC在调用这些方法时并不通过消息派发机制，而是直接调用底层C版本，能够节省很多CPU周期，提升性能。这也是这些方法在ARC下不可被覆写的一个原因。</p>
<p>ARC的另一个优化是，在编译期，能够把互相抵消的<code>retain</code>, <code>release</code>, <code>autorelease</code>化简。如果在一个对象上执行了多次保留与释放的操作，那么ARC可以成对移除这两个操作。这样的实现通过设置标志位来执行。</p>
<p>例如，ARC在运行期检测出当<code>autorelease</code>后紧跟<code>retain</code>时，不直接调用对象的<code>autorelease</code>方法，而是改为调用<code>objc_autoreleaseReturnValue</code>. 用标志位的方法来消除多余操作。</p>
<pre><code class="objective-c">/**objc_autoreleaseReturnValue 伪代码**/
id objc_autoreleaseReturnValue(id object) {
  if(/*调用者之后还会retain这个对象*/) {
    set_flag(object);    // 设置标志位
    return object;    // 直接返回
  } else {
    return [object autorelease];
  }
}</code></pre>
<p>同理，若是执行<code>retain</code>后紧跟<code>autorelease</code>, 则改为调用<code>obj_retainAutoreleasedReturnValue</code></p>
<pre><code class="objective-c">/**obj_retainAutoreleasedReturnValue 伪代码**/
id obj_retainAutoreleasedReturnValue(id object) {
  if(get_flag(object)) {    // 检测到标志位被设置
    clear_flag(object);    // 清除标志位
    return object;    // 返回
  } else {
    return [object retain];
  }
}</code></pre>
<p>设置和检测标志位，比直接调用<code>autorelease</code>和<code>retain</code>更快</p>
<h3 id="ARC下的内存管理语义"><a href="#ARC下的内存管理语义" class="headerlink" title="ARC下的内存管理语义"></a>ARC下的内存管理语义</h3><p>以设置方法为例，当我们使用ARC时只需这么写，ARC能够自动添加相关的<code>retain</code>和<code>release</code>操作</p>
<pre><code class="objective-c">- (void) setObject: (id) object {
  _object = object;
}</code></pre>
<p>如果是MRC，需要我们手动添加<code>retain</code>和<code>release</code>的操作</p>
<pre><code class="objective-c">- (void) setObject: (id) object {
  [_object release];
  _object = [object retain];
}</code></pre>
<p>但是这么写会出现问题。如果新值和旧值相同，并且当前只有该对象在引用这个值，那么设置方法中的<code>release</code>会让<code>_object</code>的引用计数为0，从而被回收，导致应用程序崩溃。而ARC避免这种情况的做法是，以一种更安全的方式来设置：</p>
<pre><code class="objective-c">- (void) setObject: (id) object {
  [object retain];    // 保留新值
  [_object release];    // 释放旧值
  _object = object;        // 设置
}</code></pre>
<p>使用ARC避免了这种边界情况，而且使得代码的编写更加简洁。我们可以用所有权修饰符来控制ARC下对象的内存管理语义：</p>
<ul>
<li><code>__strong</code>: 默认语义，只要有一个被它修饰的指针指向某对象，这个对象就不能被回收。</li>
<li><code>__weak</code>: 并不能保证被修饰的指针指向的对象一定存活。当某对象没有被强引用时，其弱引用会被设置为nil</li>
<li><code>__unsafe_unretained</code>: 并不能保证被修饰的指针指向的对象一定存活。与<code>__weak</code>不同, 当某对象没有被强引用时，其弱引用也不会被设置为<code>nil</code>，如果它引用的对象被销毁，这个指针会成为悬挂指针</li>
<li><code>__autoreleasing</code>: 把对象按引用传递给方法时，使用这个特殊的修饰符，这个值在方法返回时自动释放。</li>
</ul>
<p>需要留意的是，修饰符修饰的引用也有其作用范围，超出范围之外即便是<code>__strong</code>修饰的也会失效，应该被释放。当带有<code>__strong</code> 修饰符的变量在持有对象时，如果多个对象相互持有，很容易发生循环引用，进而引发内存泄露。例如：</p>
<pre><code class="objective-c">NSURL *url = [NSURL URLWithString:@&quot;http://www.example.com&quot;];
MyNetworkFetcher * fetcher = [[MyNetworkFetcher alloc] initWithURL];
[fetcher startWithCompletion:^(BOOL success) {
  NSLog(@&quot;Successfully fetching from %@&quot;, fetcher.url);
}]</code></pre>
<p>此段代码中，由于块能够自动保留捕获的全部对象，因此这个块保留了<code>fetcher</code>,而<code>fetcher</code>本身又引用了这个块，因此构成了保留环。解除保留环最常用的就是利用__weak修饰局部变量，这样，当强引用释放，弱引用也会被设置为nil，从而解除保留环。我们可以这么修复这段代码：</p>
<pre><code class="objective-c">NSURL *url = [NSURL URLWithString:@&quot;http://www.example.com&quot;];
MyNetworkFetcher * fetcher = [[MyNetworkFetcher alloc] initWithURL];
MyNetworkFetcher * __weak weakFetcher = fetcher;
[fetcher startWithCompletion:^(BOOL success) {
  NSLog(@&quot;Successfully fetching from %@&quot;, weakFetcher.url);
}]</code></pre>
<p>ARC下无法直接调用<code>autorelease</code>方法，也无法使用<code>NSAutoreleasePool</code>类, 但是我们可以通过<code>@autoreleasepool</code>块来代替<code>NSAutoreleasePool</code>进行对象的生成、持有、废弃的作用域</p>
<pre><code class="objective-c">@autoreleasepool{
  id __autoreleasing object = [[NSObject alloc] init];
}</code></pre>
<p>但是通常<code>__autoreleasing</code>并不显式调用，因为@autoreleasepool块指明了对象的作用域，若是最后需要在超出作用域的范围使用变量，则编译器会自动注册<code>autoreleasepool</code>对象来完成推迟release这一操作。</p>
<h3 id="ARC使用规则"><a href="#ARC使用规则" class="headerlink" title="ARC使用规则"></a>ARC使用规则</h3><p>最后，在ARC有效的情况下编译源代码需要遵守一定的规则：</p>
<ul>
<li>不能使用<code>retain/release/retainCount/autorelease</code></li>
<li>不能使用<code>NSAllocateObject/NSDeallocateObject</code></li>
<li>遵守内存管理的方法命名规则</li>
<li>不要显示调用<code>dealloc</code></li>
<li>使用<code>@autoreleasepool</code>块代替<code>NSAutoreleasePool</code></li>
<li>不要使用<code>NSZone</code></li>
<li>对象型变量不能作为C语言结构体的成员</li>
<li>显示转换<code>id</code>和<code>void</code></li>
</ul>
</article><br><br><span class="next-post"><a href="/2020/02/04/Comprehension-of-SDWebImage/" itemprop="url">Older Post ⇒</a></span><br><br><br></main></body></html>